/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package lob.example;

import java.io.*;
import java.net.*;
import java.util.TimerTask;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;

import com.fasterxml.jackson.core.JacksonException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;

import lob.LimitOrderBook;
import lob.LimitOrderBook.Side;

class BitstampOrderDeserializer extends StdDeserializer<BitstampOrder> {
    public BitstampOrderDeserializer() {
        this(null);
    }

    public BitstampOrderDeserializer(Class<?> vc) {
        super(vc);
    }

    @Override
    public BitstampOrder deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JacksonException {
        JsonNode node = p.getCodec().readTree(p);
        BitstampOrder order = new BitstampOrder();
        String event = node.get("event").asText();
        switch (event) {
            case "order_created":
                order.event = BitstampOrderEvent.Created;
                break;
            case "order_deleted":
                order.event = BitstampOrderEvent.Deleted;
                break;
            case "order_changed":
                order.event = BitstampOrderEvent.Changed;
                break;
            default:
                throw new IOException(
                        "received unrecognised 'event', only 'order_created', 'order_deleted' or 'order_changed' is valid.");
        }

        order.id = node.get("data").get("id").asLong();

        int side = node.get("data").get("order_type").asInt();
        switch (side) {
            case 0:
                order.side = Side.BUY;
                break;
            case 1:
                order.side = Side.SELL;
                break;
            default:
                throw new IOException("received unrecognised 'order_type', only 0 or 1 is valid.");
        }

        order.amount = (long) (node.get("data").get("amount").asDouble() * 1e9);
        order.price = node.get("data").get("price").asLong();

        return order;
    }
}

enum BitstampOrderEvent {
    Created,
    Deleted,
    Changed,
}

@JsonDeserialize(using = BitstampOrderDeserializer.class)
class BitstampOrder {
    BitstampOrderEvent event;
    Side side;
    long id;
    long amount;
    long price; // the order is a taker if its price is 0.

    @Override
    public String toString() {
        return event + " id: " + id + " side: " + side + " amount: " + amount + " price: " + price;
    }
}

class BitstampClient extends WebSocketClient {
    private final static String uri = "wss://ws.bitstamp.net";
    private ObjectMapper mapper = new ObjectMapper();
    private PrintWriter writer;
    private LimitOrderBook book;
    private BufferedReader reader;

    public BitstampClient(BufferedReader reader, LimitOrderBook book) throws URISyntaxException {
        this(book);
        this.reader = reader;
        this.book = book;
    }

    public BitstampClient(LimitOrderBook book) throws URISyntaxException {
        super(new URI(BitstampClient.uri));
        this.book = book;
    }

    public BitstampClient(LimitOrderBook book, PrintWriter writer) throws URISyntaxException {
        this(book);
        this.writer = writer;
    }

    public void read() throws IOException {
        String line = reader.readLine();
        while (line != null) {
            handleOrderMessage(line);
            line = reader.readLine();
        }
    }

    private void handleOrderMessage(String message) {
        // try to parse it as an order message
        try {
            BitstampOrder order = mapper.readValue(message, BitstampOrder.class);

            switch (order.event) {
                case Created:
                    if (order.price == 0) // if the price is 0 then it is a market order
                        book.market(book.new Order(order.id, order.side, order.amount, order.price));
                    else // limit otherwise
                        book.limit(book.new Order(order.id, order.side, order.amount, order.price));
                    break;
                case Deleted:
                    book.cancel(order.id);
                    break;
                case Changed:
                    // TODO: book.modify
                    break;
            }

            // System.out.println(order.event);
            // System.out.println(book);
        } catch (Exception _e1) {
            try {
                JsonNode node = mapper.readTree(message);
                System.out.println("Received non-order message: " + node);
            } catch (Exception e2) {
                System.err.println("Failed to parse message as JSON: " + e2);
            }
        }
    }

    @Override
    public void onOpen(ServerHandshake handshake) {
        System.out.println("Successfully connected to " + BitstampClient.uri);

        // Subscribe to data feeds
        send("""
                {
                    "event": "bts:subscribe",
                    "data": {
                        "channel": "live_orders_btcusd"
                    }
                }""");
    }

    @Override
    public void onMessage(String message) {
        if (writer != null)
            writer.println(message);
        handleOrderMessage(message);
        System.out.println(book.best_sell());
        System.out.println("-------------------");
        System.out.println(book.best_buy());
        System.out.println();
    }

    @Override
    public void onClose(int code, String reason, boolean remote) {
        writer.close();
        System.out.println(
                "Connection closed by " + (remote ? "remote peer" : "us") + " Code: " + code + " Reason: "
                        + reason);
    }

    @Override
    public void onError(Exception ex) {
        ex.printStackTrace();
    }
}

public class Bitstamp {
    private final static String filepath = System.getProperty("user.dir")
            + "/src/main/resources/l3_orderbook.ndjson";

    public static void main(String[] args) throws URISyntaxException, IOException {
        // check command line arguments
        if (args.length != 1) {
            System.out.println("usage: lob.example.Bitstamp <mode>");
            System.out.println(" <mode>        Mode for the program, possible values: [download, local, live]");
            System.exit(1);
        }

        LimitOrderBook book = new LimitOrderBook();
        BitstampClient client;
        String mode = args[0];

        switch (mode) {
            case "download":
                PrintWriter writer = new PrintWriter(new FileWriter(filepath));
                client = new BitstampClient(book, writer);
                client.connect();

                // Run a delayed task of 60 seconds to stop the download
                TimerTask delayedTask = new TimerTask() {
                    public void run() {
                        try {
                            client.closeBlocking();
                        } catch (InterruptedException e) {
                            System.err.println("Failed to close websocket connection");
                            e.printStackTrace();
                        }

                        writer.flush();
                        System.out.println("Successfully download L3 Orderbook data to " + filepath);
                        System.exit(0);
                    }
                };
                ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
                executor.schedule(delayedTask, 60, TimeUnit.SECONDS);

                break;
            case "local":
                client = new BitstampClient(new BufferedReader(new FileReader(filepath)), book);
                client.read();
                System.out.println("Completed reading from " + filepath);
                System.exit(0);

                break;
            case "live":
                client = new BitstampClient(book);
                client.connect();

                break;
            default:
                throw new IOException(
                        "unrecognised mode '" + mode + "', only values from [download, local, live] is acceptable");
        }
    }
}
